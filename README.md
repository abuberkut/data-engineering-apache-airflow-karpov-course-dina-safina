# Введение в ETL 

<details>
<summary>Требования</summary>
  
- Базовый уровень Python
- Здравый смысл
- Понимание проектирования DWH (чтобы не облажаться при построении архитектуры), инструменты для реализации ETL (чтобы правильно забирать данные или складывать в хранилище), много практики построения ETL
</details>

<details>
<summary>1. Что такое ETL</summary>
  
  - Extract (CSV, DB Table, API…)
  - Transform (with Python, deduplication, formats…)
  - Load (Insert in DWH), 
  - ELT - E + L (сырые данные сначала загружаются в хранилище), T
  1. Перенос данных из одного или нескольких источников в большое хранилище данных, он нужен не всегда (когда небольшой проект, 1-2 БД с репликами).
  2. Если данные хранятся в разных местах, то понадобится хранилище чтобы их анализировать, нужен ETL
</details>

<details>
<summary>2. Как правильно готовить ETL</summary>
  
    1. Принципы построения ETL
        1. Чистый код
        2. Простота
        3. Единообразие (Пайплана)
        4. Время выполнения пайплайна (если долго, то что-то не так)
        5. Меньше сетевого трафика
        6. Работа с репликой (чтобы не ломать мэйн БД)
        7. Оптимизация забора данных (БД индексы…)
        8. Партицирование
        9. Инкрементальный пересчет витрин (снепшоты)
        10. Загрузка всего без ограничений (сырые данные из источника - это лучше)
        11. Избавляться от неактуального (Аудит пайплайнов - оставлять только нужные)
        12. Идемпотентность (лучше использовать merge, чем insert)
        13. Аудиторский след (сырые данные хранить в DWH, чтобы в случае ошибки заново на месте пересчитать)
    2. Будьте готовы
        1. Отсутствие целостности (данные в источниках не всегда идеальны, несоответствия мелкие будут)
        2. Сетевые проблемы (идемпотентность должно решать эту проблему)
        3. Незапланированные изменения (в БД или АПИ,… ) 
        4. Пайплайны будут задерживаться (акции, память пайплайна заняли много) - контролировать важные пайплайны
        5. Данные из разных системах противоречивы (одна система хранит - дни, другая - сумму, другая - сумму фрода)
</details>

<details>
<summary>3. Обзор планировщиков (scheduler - запустить в нужный момент задачу)</summary>
  
    1. CRON
        1. «+» Максимально простой, «-» максимально простой
    2. Jenkins/gitlab CI
        1.  Предназначено больше для. CI/CD
    3. Написать свой (google, yandex,...)
    4. Платные - дорогие, нет доступа к коду, есть поддержка, визуальный редактор
    5. Опен сорс - бесплатно, можно посмотреть код, можно контрибютить, риск ошибок в коде (Apache Oozie, NiFi; Talend (Java), Luigi, Airflow - остальные на Python) 
</details>

<details>
<summary>4. Почему Airflow</summary>
  
    1. Open source
    2. Отличная документация
    3. Простий код на Python 
    4. Удобный UI
    5. Алертинг и мониторинг
    6. Интеграция с основными источниками
    7. Кастомизацию
    8. Масштабирование (Докер, кластеры)
    9. Большое комьюнити
</details>
